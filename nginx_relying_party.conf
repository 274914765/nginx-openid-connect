# This is the backend application we are protecting with OpenID Connect
# For this configuration, all resources are protected
upstream my_backend {
    server 10.0.0.1:80;
    zone my_backend 64k;
}

# Custom log format to include the 'sub' claim in the REMOTE_USER field
log_format main_jwt '$remote_addr $jwt_claim_sub $remote_user [$time_local] "$request" $status '
                    '$body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for"';

# nginScript functions for code exchange and hashing for secure nonce validation
js_include /etc/nginx/conf.d/openid_connect.js;
js_set $requestid_hash hash_RequestId;
js_set $nonce_hash hash_NonceCookie;
js_set $auth_token get_auth_token;

# If we receive a nonce in the JWT then we will use the auth_nonce cookie to check that
# the JWT can be validated as being directly related to the original (unauthenticated)
# request by this client. This mitigates against token replay attacks.
map $jwt_claim_nonce $client_nonce {
    ""      "";
    default $nonce_hash;
}

# The frontend server - reverse proxy with OpenID Connect authentication
#
server {
    set $oidc_token_type       "id_token"; # What to use as session cookie (access_token or id_token)

    # IdP configuration
    set $oidc_authz_endpoint  "https://my-idp.example.com/oauth2/oidc/authorize";    # CHANGE ME
    set $oidc_token_endpoint  "https://my-idp.example.com/oauth2/oidc/access_token"; # CHANGE ME
    set $oidc_client          "my-client-id";                                        # CHANGE ME
    set $client_secret        "my-client-secret";                                    # CHANGE ME

    listen 8010; # Use TLS/SSL in production

    location / {
        # This site is protected with OpenID Connect
        auth_jwt "OpenID Connect" token=$cookie_auth_token;
        auth_jwt_key_file /etc/nginx/my-idp.jwk;                                     # CHANGE ME

        # Absent/invalid OpenID Connect token will (re)start auth process
        error_page 401 @oidc_auth;

        # Check that the nonce value matches the cookie we set when starting auth flow
        if ($jwt_claim_nonce != $client_nonce) {
            return 403;
        }

        # Successfuly authenticated users are proxied to the backend,
        # with username passed as HTTP header
        proxy_set_header username $jwt_claim_email;
        proxy_pass http://my_backend; # The backend site/app

        access_log /var/log/nginx/oidc_access.log main_jwt;
        error_log  /var/log/nginx/oidc_error.log debug;
    }

    location @oidc_auth {
        # Redirect this request to the OpenID Connect identity provider login page for this server{}
        # Using authorization code flow (nonce sent to IdP is hash of $request_id)
        add_header Set-Cookie "auth_nonce=$request_id; HttpOnly;"; # Random value
        add_header Set-Cookie "auth_redir=$uri; HttpOnly;";        # So we know where to come back to

        # This URL should work for most OpenID Connect providers.
        # Adjust the scope or state values as required
        return 302 "$oidc_authz_endpoint?response_type=code&scope=openid+profile+email&client_id=$oidc_client&state=0&redirect_uri=$scheme://$host:$server_port$redir_location&nonce=$requestid_hash";
        access_log /var/log/nginx/oidc_auth.log main;
    }

    set $redir_location "/_codexch";
    location = /_codexch {
        # This is where the IdP will send the authorization code after user login
        subrequest_output_buffer_size 4k;
        js_content oidc_codeExchange; # nginScript function to obtain JWT and issue cookie
        add_header Set-Cookie "auth_token=$auth_token; Path=/; HttpOnly;"; # Use Domain and Secure flags in production

        access_log /var/log/nginx/oidc_auth.log main;
        error_log  /var/log/nginx/oidc_error.log debug;
    }

    location = /_token {
        # This location is called by oidc_codeExchange(). We use the proxy_ directives
        # to construct the OpenID Connect token request, as per:
        #  http://openid.net/specs/openid-connect-core-1_0.html#TokenRequest
        internal;
        resolver          127.0.0.1; # For DNS lookup of $oidc_token_endpoint / CHANGE ME;
        proxy_set_header  Content-Type "application/x-www-form-urlencoded";
        proxy_set_body    "grant_type=authorization_code&code=$arg_code&client_id=$oidc_client&client_secret=$client_secret&redirect_uri=$scheme://$host:$server_port$redir_location";
        proxy_pass        $oidc_token_endpoint;
        proxy_buffers     8 32k; # Increase buffers to hold a complete response
        proxy_buffer_size 128k;
        proxy_busy_buffers_size 128k;

        access_log /var/log/nginx/oidc_auth.log main;
        error_log  /var/log/nginx/oidc_error.log debug;
    }
}
